#!/usr/bin/env python3
"""
Mundi Engine - Lua 바인딩 자동 생성 도구

UPROPERTY와 UFUNCTION 매크로를 파싱하여
.generated.cpp 파일을 자동 생성합니다.

사용법:
    python generate.py --source-dir <소스 디렉토리> --output-dir <출력 디렉토리>
"""

import argparse
import sys
import os
from pathlib import Path
import subprocess

# Add current script directory to Python path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from header_parser import HeaderParser
from property_generator import PropertyGenerator
from lua_generator import LuaBindingGenerator
from vcxproj_parser import VcxprojParser


GENERATED_HEADER_TEMPLATE = """// Auto-generated file - DO NOT EDIT!
// Generated by Tools/CodeGenerator/generate.py

#pragma once

// Macro expansion for GENERATED_REFLECTION_BODY()
// This file must be included BEFORE the class definition
#ifdef CURRENT_CLASS_GENERATED_BODY
#undef CURRENT_CLASS_GENERATED_BODY
#endif
#define CURRENT_CLASS_GENERATED_BODY \\
public: \\
    using Super = {parent_class}; \\
    using ThisClass_t = {class_name}; \\
    static UClass* StaticClass() \\
    {{ \\
        static UClass Cls{{ "{class_name}", {parent_class}::StaticClass(), sizeof({class_name}) }}; \\
        static bool bRegistered = (UClass::SignUpClass(&Cls), true); \\
        return &Cls; \\
    }} \\
    virtual UClass* GetClass() const override {{ return {class_name}::StaticClass(); }} \\
    {class_name}(const {class_name}&) = default; \\
    {duplicate_method} \\
private: \\
    static void StaticRegisterProperties(); \\
    static const bool bPropertiesRegistered; \\
public:
"""

DUPLICATE_METHOD_CONCRETE = """{class_name}* Duplicate() const override \\
    {{ \\
        {class_name}* NewObject = ObjectFactory::DuplicateObject<{class_name}>(this); \\
        NewObject->DuplicateSubObjects(); \\
        NewObject->PostDuplicate(); \\
        return NewObject; \\
    }}"""

DUPLICATE_METHOD_ABSTRACT = """{class_name}* Duplicate() const override \\
    {{ \\
        assert(false && "Cannot duplicate abstract class {class_name}"); \\
        return nullptr; \\
    }}"""

GENERATED_CPP_TEMPLATE = """// Auto-generated file - DO NOT EDIT!
// Generated by Tools/CodeGenerator/generate.py

#include "pch.h"
#include "{header_include}"
#include "{object_macros_include}"
#include "{lua_helpers_include}"

// ===== Class Factory Registration (IMPLEMENT_CLASS) =====
{implement_class_code}

// ===== Property Reflection =====
{property_code}

// ===== Lua Binding =====
{lua_code}
"""


def write_file_if_different(file_path: Path, new_content: str) -> bool:
    """
    파일 내용이 실제로 다를 때만 파일을 씁니다.
    타임스탬프를 유지하여 불필요한 재컴파일을 방지합니다.

    Returns:
        True if file was written, False if content was identical
    """
    # 파일이 이미 존재하고 내용이 같으면 건너뛰기
    if file_path.exists():
        existing_content = file_path.read_text(encoding='utf-8')
        if existing_content == new_content:
            return False

    # 내용이 다르거나 파일이 없으면 쓰기
    file_path.write_text(new_content, encoding='utf-8')
    return True


def generate_header_file(class_info):
    """.generated.h 파일 생성"""
    # 추상 클래스는 순수 가상 Duplicate(), 일반 클래스는 구체적 구현
    if class_info.is_abstract:
        duplicate_method = DUPLICATE_METHOD_ABSTRACT.format(class_name=class_info.name)
    else:
        duplicate_method = DUPLICATE_METHOD_CONCRETE.format(class_name=class_info.name)

    return GENERATED_HEADER_TEMPLATE.format(
        class_name=class_info.name,
        parent_class=class_info.parent,
        duplicate_method=duplicate_method
    )


def generate_implement_class(class_info):
    """IMPLEMENT_CLASS 매크로 확장 코드 생성"""
    class_name = class_info.name

    # 추상 클래스는 팩토리 함수를 nullptr로 등록
    if class_info.is_abstract:
        factory_lambda = "nullptr"
    else:
        factory_lambda = f"[]() -> UObject* {{ return new {class_name}(); }}"

    return f"""
// IMPLEMENT_CLASS({class_name}) expansion
namespace {{
    struct {class_name}FactoryRegister
    {{
        {class_name}FactoryRegister()
        {{
            ObjectFactory::RegisterClassType(
                {class_name}::StaticClass(),
                {factory_lambda}
            );
        }}
    }};
    static {class_name}FactoryRegister GRegister_{class_name};
    static bool bIsRegistered_{class_name} = [](){{ {class_name}::StaticClass(); return true; }}();
}}

// Static member initialization for reflection registration
const bool {class_name}::bPropertiesRegistered = []() {{
    {class_name}::StaticRegisterProperties();
    return true;
}}();
"""


def generate_cpp_file(class_info, prop_gen, lua_gen, vcxproj_parser: VcxprojParser = None):
    """.generated.cpp 파일 생성"""
    # vcxproj_parser가 있으면 사용, 없으면 기본 동작
    if vcxproj_parser:
        # 헤더 파일을 프로젝트 루트 기준 절대 경로로 변환
        header_include = vcxproj_parser.get_project_relative_path(class_info.header_file)

        # ObjectMacros.h를 VS처럼 resolve하여 절대 경로로 변환
        object_macros_include = vcxproj_parser.convert_to_absolute_include("ObjectMacros.h")

        # LuaBindHelpers.h를 VS처럼 resolve하여 절대 경로로 변환
        lua_helpers_include = vcxproj_parser.convert_to_absolute_include("LuaBindHelpers.h")
    else:
        # vcxproj_parser 없으면 파일명만 사용 (fallback)
        header_include = class_info.header_file.name
        object_macros_include = "ObjectMacros.h"
        lua_helpers_include = "LuaBindHelpers.h"

    # IMPLEMENT_CLASS 코드 생성
    implement_class_code = generate_implement_class(class_info)

    # 프로퍼티 코드 생성
    property_code = prop_gen.generate(class_info)

    # Lua 바인딩 코드 생성
    lua_code = lua_gen.generate(class_info)

    # 최종 파일 내용
    return GENERATED_CPP_TEMPLATE.format(
        header_include=header_include,
        object_macros_include=object_macros_include,
        lua_helpers_include=lua_helpers_include,
        implement_class_code=implement_class_code,
        property_code=property_code,
        lua_code=lua_code
    )


def main():
    parser = argparse.ArgumentParser(
        description='Mundi Engine Lua Binding Auto-Generator'
    )
    parser.add_argument(
        '--source-dir',
        type=Path,
        required=True,
        help='소스 디렉토리 경로 (예: Source/Runtime)'
    )
    parser.add_argument(
        '--output-dir',
        type=Path,
        required=True,
        help='생성된 파일 출력 디렉토리 (예: Build/Generated)'
    )
    parser.add_argument(
        '--vcxproj',
        type=Path,
        default=None,
        help='업데이트할 .vcxproj 파일 경로 (예: Mundi.vcxproj)'
    )

    args = parser.parse_args()

    # 디렉토리 존재 확인
    if not args.source_dir.exists():
        print(f"[ERROR] Source directory not found: {args.source_dir}")
        sys.exit(1)

    # 출력 디렉토리 생성
    args.output_dir.mkdir(parents=True, exist_ok=True)

    print("=" * 60)
    print(" Mundi Engine - Code Generator")
    print("=" * 60)
    print(f" Source: {args.source_dir}")
    print(f" Output: {args.output_dir}")

    # vcxproj 파서 초기화 (include 경로 자동 해석용)
    vcxproj_parser = None
    if args.vcxproj and args.vcxproj.exists():
        print(f" Vcxproj: {args.vcxproj}")
        vcxproj_parser = VcxprojParser(args.vcxproj)
        print(f" Include Dirs: {len(vcxproj_parser.include_dirs)} directories parsed")
    else:
        print(f" Vcxproj: Not specified (using fallback include paths)")
    print()

    # 파서 초기화
    header_parser = HeaderParser()
    prop_gen = PropertyGenerator()
    lua_gen = LuaBindingGenerator()

    # 헤더 파일 스캔
    print(" Scanning for reflection classes...")
    classes = header_parser.find_reflection_classes(args.source_dir)

    if not classes:
        print("[WARNING] No classes with GENERATED_REFLECTION_BODY() found.")
        return

    print(f"\n Found {len(classes)} reflection class(es)\n")

    # 각 클래스에 대해 .generated.h와 .generated.cpp 생성
    generated_files = []
    updated_count = 0
    skipped_count = 0

    for class_info in classes:
        # .generated.h 파일 생성
        header_output = args.output_dir / f"{class_info.name}.generated.h"
        header_code = generate_header_file(class_info)
        header_updated = write_file_if_different(header_output, header_code)
        if header_updated:
            updated_count += 1
        generated_files.append(header_output)

        # .generated.cpp 파일 생성
        cpp_output = args.output_dir / f"{class_info.name}.generated.cpp"
        cpp_code = generate_cpp_file(class_info, prop_gen, lua_gen, vcxproj_parser)
        cpp_updated = write_file_if_different(cpp_output, cpp_code)
        if cpp_updated:
            updated_count += 1
        generated_files.append(cpp_output)

        # 상태 표시
        if header_updated or cpp_updated:
            status = " Updated"
        else:
            status = "  Skipped (no changes)"
            skipped_count += 1

        print(f"{status}: {class_info.name}")
        if header_updated:
            print(f"  ├─ {header_output.name} (modified)")
        if cpp_updated:
            print(f"  ├─ {cpp_output.name} (modified)")
        print(f"  ├─ Properties: {len(class_info.properties)}")
        print(f"  └─ Functions:  {len([f for f in class_info.functions if f.metadata.get('lua_bind')])}")

    print()
    print("=" * 60)
    print(f" Code generation complete!")
    print(f"   Total files: {len(generated_files)}")
    print(f"   Updated: {updated_count}")
    print(f"   Skipped: {skipped_count * 2} (unchanged)")
    print("=" * 60)

    # vcxproj 업데이트
    if args.vcxproj and args.vcxproj.exists():
        print()
        print("=" * 60)
        print(" Updating Visual Studio Project...")
        print("=" * 60)

        # vcxproj_updater.py 실행
        updater_script = Path(__file__).parent / "vcxproj_updater.py"
        if updater_script.exists():
            cmd = [sys.executable, str(updater_script), str(args.vcxproj)] + [str(f) for f in generated_files]
            try:
                result = subprocess.run(cmd, capture_output=True, text=True, encoding='utf-8')
                print(result.stdout)
                if result.returncode != 0:
                    print(f"[WARNING] vcxproj update failed: {result.stderr}")
            except Exception as e:
                print(f"[WARNING] Failed to run vcxproj updater: {e}")
        else:
            print(f"[WARNING] vcxproj_updater.py not found at {updater_script}")
    elif args.vcxproj:
        print(f"\n[WARNING] vcxproj file not found: {args.vcxproj}")


if __name__ == '__main__':
    main()
